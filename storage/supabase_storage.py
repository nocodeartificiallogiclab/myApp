"""Supabase storage handler for persisting transactions and budgets."""

import os
from typing import List, Optional
from datetime import date

from supabase import create_client, Client

from models.transaction import Transaction
from models.budget import Budget


class SupabaseStorageHandler:
    """Handles persistence of transactions and budgets using Supabase.
    
    This class encapsulates all Supabase operations and provides a clean
    interface for reading and writing application data to Supabase.
    """
    
    def __init__(self, supabase_url: Optional[str] = None, supabase_key: Optional[str] = None) -> None:
        """Initialize the Supabase storage handler.
        
        Args:
            supabase_url: Supabase project URL (defaults to SUPABASE_URL env var)
            supabase_key: Supabase anon/public key (defaults to SUPABASE_KEY env var)
        """
        self.supabase_url = supabase_url or os.getenv("SUPABASE_URL", "")
        self.supabase_key = supabase_key or os.getenv("SUPABASE_KEY", "")
        
        if not self.supabase_url or not self.supabase_key:
            raise ValueError(
                "Supabase URL and key must be provided either as parameters "
                "or via SUPABASE_URL and SUPABASE_KEY environment variables"
            )
        
        self.client: Client = create_client(self.supabase_url, self.supabase_key)
    
    def save_transaction(self, transaction: Transaction) -> None:
        """Save a transaction to Supabase.
        
        Args:
            transaction: Transaction object to save
        """
        transaction_data = {
            "date": transaction.date.isoformat(),
            "amount": float(transaction.amount),
            "category": transaction.category,
            "description": transaction.description,
            "type": transaction.type,
        }
        
        if transaction.id:
            # Update existing transaction
            try:
                # Try to update using UUID
                self.client.table("transactions").update(transaction_data).eq("id", transaction.id).execute()
            except Exception:
                # If UUID fails, try string conversion
                self.client.table("transactions").update(transaction_data).eq("id", str(transaction.id)).execute()
        else:
            # Insert new transaction (UUID will be generated by database)
            result = self.client.table("transactions").insert(transaction_data).execute()
            if result.data and len(result.data) > 0:
                transaction.id = str(result.data[0]["id"])
    
    def load_all_transactions(self) -> List[Transaction]:
        """Load all transactions from Supabase.
        
        Returns:
            List of Transaction objects
        """
        result = self.client.table("transactions").select("*").order("date", desc=True).execute()
        
        transactions = []
        for row in result.data:
            transactions.append(
                Transaction(
                    id=str(row["id"]),
                    date=date.fromisoformat(row["date"]),
                    amount=float(row["amount"]),
                    category=row["category"],
                    description=row.get("description", ""),
                    type=row["type"],
                )
            )
        
        return transactions
    
    def delete_transaction(self, transaction_id: str) -> bool:
        """Delete a transaction by ID.
        
        Args:
            transaction_id: ID of the transaction to delete
            
        Returns:
            True if transaction was deleted, False if not found
        """
        try:
            result = self.client.table("transactions").delete().eq("id", transaction_id).execute()
            return result.data is not None and len(result.data) > 0
        except Exception:
            return False
    
    def save_budget(self, budget: Budget) -> None:
        """Save a budget to Supabase.
        
        Args:
            budget: Budget object to save
        """
        budget_data = {
            "category": budget.category,
            "monthly_limit": float(budget.monthly_limit),
        }
        
        # Use upsert to insert or update
        self.client.table("budgets").upsert(budget_data, on_conflict="category").execute()
    
    def load_all_budgets(self) -> List[Budget]:
        """Load all budgets from Supabase.
        
        Returns:
            List of Budget objects
        """
        result = self.client.table("budgets").select("*").execute()
        
        budgets = []
        for row in result.data:
            budgets.append(
                Budget(
                    category=row["category"],
                    monthly_limit=float(row["monthly_limit"]),
                )
            )
        
        return budgets
    
    def delete_budget(self, category: str) -> bool:
        """Delete a budget by category.
        
        Args:
            category: Category of the budget to delete
            
        Returns:
            True if budget was deleted, False if not found
        """
        try:
            result = self.client.table("budgets").delete().eq("category", category).execute()
            return result.data is not None and len(result.data) > 0
        except Exception:
            return False
